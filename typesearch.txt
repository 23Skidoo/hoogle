Type searching

Given an oracle for alias information and instance information

Given two signatures a and b, there are N steps to get between them (computable)

Steps have a non-linear cost, so given N steps there is a cost to that transition (computable)


-- not symetric
difference :: Oracle -> TypeSig -> TypeSig -> Bag Step

cost :: Bag Step -> Double

want to find the type signatures, sorted by cost from the current spot

oracle :: Oracle

database :: [TypeSig]

find :: TypeSig -> [TypeSig]
find x = take 25 $ sortOn (cost . difference oracle x) database

What properties do I have?

-- differences are a set, adding members can only increase the cost
cost (x:xs) >= cost xs
cost xs == cost (permute xs)

-- costs are transitive
cost (difference o t1 t2) + cost (difference o t2 t3) <= cost (difference o t1 t3)

GOAL
Precompute some information so that don't need to search the entire database to find the smallest

Triangulation?
- given two points, can you predict where a differences will lie?

Isomeres?
- are some set of types sufficiently small in difference that you can group them?

Boundaries?
- can you say a minimum of how much this must cost?



rewrite rules:

Maybe a ~> a, has a small cost
FilePath ~> String, has a very small cost

Functor f => (a -> b) -> f a -> f b


(a -> b) -> Functor f a -> Functor f b

[] ~> Functor f
Functor f ~> f

readShow :: (Read a, Show a) => RS a
readShow :: Read (Show a)

Read a ~> a
Show a ~> a

YAY, no contexts.

So you have a number of localised rewrites you can apply, and a database of things to apply it to - 43000 types

ShakeOptions has 21 types, all will have the rule

a ~> a -> b

a ~> ShakeOptions

ShakeOptions ~> Monoid m



Contexts are gone, everything is a rewrite:



Given 



how does searching for ShakeOptions find everything quickly?


_ -> IO Int

Monad m => _ -> m Int

()




ANSWER
======

TYPE SEARCH

difference :: Oracle -> TypeSig -> TypeSig -> Bag Step

cost :: Bag Step -> Double

want to find the type signatures, sorted by cost from the current spot

oracle :: Oracle

database :: [TypeSig]

find :: TypeSig -> [TypeSig]
find x = take 25 $ sortOn (cost . difference oracle x) database

What properties do I have?

-- differences are a set, adding members can only increase the cost
cost (x:xs) >= cost xs
cost xs == cost (permute xs)

-- costs are transitive
cost (difference o t1 t2) + cost (difference o t2 t3) <= cost (difference o t1 t3)


Functor a ~> a
Functor [] ~> []


(a -> b) -> Functor f a -> Functor f b

[] ~> Functor f (cheap)
ShakeOptions ~> Monoid a (cheap)

argument reordering and omission is expensive...


directed rewrites should be cheap.


Functor,Eq~f a

TYPE SEARCH

difference :: Oracle -> TypeSig -> TypeSig -> Bag Step

cost :: Bag Step -> Double

want to find the type signatures, sorted by cost from the current spot

oracle :: Oracle

database :: [TypeSig]

find :: TypeSig -> [TypeSig]
find x = take 25 $ sortOn (cost . difference oracle x) database

What properties do I have?

-- differences are a set, adding members can only increase the cost
cost (x:xs) >= cost xs
cost xs == cost (permute xs)

-- costs are transitive
cost (difference o t1 t2) + cost (difference o t2 t3) <= cost (difference o t1 t3)


Functor a ~> a
Functor [] ~> []


(a -> b) -> Functor f a -> Functor f b

[] ~> Functor f (cheap)
ShakeOptions ~> Monoid a (cheap)

argument reordering and omission is expensive...


directed rewrites should be cheap.


Functor,Eq~f a


ANSWER
------

matchSig :: TypeSig -> TypeSig -> Double
matchTag :: TypeSig -> Tag -> Bool
hasTag :: TypeSig -> Tag -> Bool
:: [Tag]
:: [TypeSig]

Have a file of which tags you have, and what sigs they related to
Search all tags to get a subset, search the intersection of all sigs they suggest




ANSWER
------

matchSig :: TypeSig -> TypeSig -> Double
matchTag :: TypeSig -> Tag -> Bool
hasTag :: TypeSig -> Tag -> Bool
:: [Tag]
:: [TypeSig]

Have a file of which tags you have, and what sigs they related to
Search all tags to get a subset, search the intersection of all sigs they suggest

Have:

.ctors = mapping from Maybe to a# 1, a 2 char identifier plus the arity

.types = list of types from beginning to end, encoded using the ctors encoding

.arity = 1 a, 2 c, 3 d - a..b are all arity 1 - sort the types by arity

.tag
:: ShakeOptions = a b c d e f g h i j - which have shakeoptions in them

:: IO -> _ = which have IO in a positive position


Trying to compute:

(?) :: TypeQ -> TypeA -> Maybe Cost

(?~) :: TypeQ~ -> TypeA~ -> Bool

such that:

(q~ ?~ a~) == False ==> isNothing (q ? a)

a~ :: ([#Context],[Ctor]) -- exactly what is in the type, no alias or instance following
-- sort the list

q~
    for each thing in the Q it must be able to be satisfied on the RHS
    C ~? q ==> if C is actually in ~a
    Int ?~ q ==> Monoid ?~ q -- can satisfy with an instance
    FilePath ?~ q ==> String ?~ q -- can follow an instance
    String ?~ q ==> Char ?~ q && [] ?~ q
    Turn q~ into a state machine based on recognisation

?~ -- can come up with a very fast state machine for q~, just apply that to a~


q# ?# a# == False ==> q ? a < Just 0.01
    If q~ requires no "rare" things (< 5% of the DB), then don't suggest "rare" things
    If the rarest ctor you require is N%, reject all things with ctors you don't want rarer than (2*N)%
    conretely: if Action a -> IO a, and Action is 2%, allow

    Problem: Searching for a -> IO a, you don't want Action a -> IO a, since Action a is pretty darn rare
    if you only have common stuff (IO is 40%), reject things which are rare (Action is 0.5%)
    so reject all with < 20% common

a# is how rare is the most rare thing
    ShakeOptions -> Action a -> IO a, ShakeOptions is the rarest thing at 0.5%

q#
    Searching for Action a -> IO a, Action is the rarest at 1%
    a -> IO a, since IO is very common (40%) don't both including anything with Action (too rare)

q# ?# a# = q# * 5 > a#
    if the rare stuff is present, then we're fine

so if q has rare things, ?~ restricts cheaply to a few

so if q has only common things, ?# restricts cheaply those which have rare bits in

sort by a~ to recognise and skip large chunks

if you can satisfy all the pieces, then try and satisfy the whole thing in detail


?* = arity based test, restrict to the arity
