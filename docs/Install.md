# Installing Hoogle locally

----------

**This page describes how Hoogle 5 might work, and has not yet been fully implemented.** 

----------

This page describes how to install and run Hoogle on your machine, for individual use, then goes on to describe how to deploy Hoogle as a server for shared use. Both configurations can search either public Haskell code, or personal/company Haskell code.

## Installing for personal use

There are three commands of interest - `generate` to generate a database, `search` to search on the command line and `server` to start a web server as a search UI. You always start with `generate`, then after a database has been generated can search with either `search` or `server`.

### Generating a database

When generating a database, there are two main questions of interest - where do you get the information to search, and where do the generated files go.

By default, Hoogle will generate the default database at `~/.hoogle/default.hoo`, but this can be configured with the `--database` flag. If you pass a custom `--database` flag, make sure to pass a similar flag when running `search` or `server.

By default, Hoogle will generate databases for all the packages on Stackage, based on databases taken from Hackage. The location of Hackage databases will automatically be overridden based on your .cabal settings files. Here are a number of examples:

* `hoogle generate` - generate for all things in Stackage based on Hackage information.
* `hoogle generate --source=file1.txt --source=local --source=stackage --source=hackage --source=tarball.tar.gz`

Which files you want to index. Currently the list on stackage, could be those locally installed, those in a .cabal file etc. A `--list` flag, defaults to `stackage=url`. Can also be `ghc-pkg`, `ghc-pkg=user` `ghc-pkg=global`. `name=p1`.

Extra metadata you want to apply. Could be a file. `+shake author:Neil-Mitchell`, `-shake author:Neil-Mitchel`. Can be sucked out of .cabal files. A `--tags` flag, defaults to `tarball=url` and `diff=renamings.txt`.

Where the haddock files are. Defaults to `tarball=hackage-url`. Can also be `file=p1.txt`. Use `--data` flag.

Defaults to: `hoogle generate --list=ghc-pkg --list=constrain=stackage-url`.

Three pieces of data:

* Which packages to index, in order.
* Metadata.


### Local Users

    hoogle generate
    hoogle map

Where to find information:

### Server Users

    hoogle generate


People might want to point at Salmon or Stackage, so different URL schemes etc.


When serving, need to decide how to pick a link, and if to follow file links.

hoogle server --follow-link 

set:project

--link=local:

--link=foo:






Hoogle has both binary databases (extension .hoo) and textual databases (extension .txt). Textual database files are a list of functions and their types, along with information about type synonyms, instances etc. The textual database files can be generated by [http://haskell.org/haddock/ Haddock] with the <tt>--hoogle</tt> flag. Support for this is now in [http://haskell.org/cabal/ Cabal] with <tt>runhaskell Setup haddock --hoogle</tt>.

A more detailed tutorial style style post on database creation is available [http://neilmitchell.blogspot.com/2008/08/hoogle-database-generation.html on the author's blog].

You can create some default databases with:

 $ hoogle data

#### Converting text databases to binary databases

A text database can be converted to a binary database with the command <tt>hoogle --convert=file.txt</tt>. Any package dependencies should be specified with <tt>+package</tt> or <tt>--data=package.hoo</tt>, and will require the binary databases for those packages. The output file can be controlled with <tt>--output=file.hoo</tt>.

#### Merging binary databases

Multiple binary databases can be merged with <tt>hoogle --combine=file1.hoo --combine=file2.hoo</tt>. As before, <tt>--output=default.hoo</tt> can be specified.

The following script (from Matt Brown) may be helpful:

```
#!/bin/bash

function combines {
  for f in ~/.hoogle/*.hoo
  do
    echo -n " $(readlink -f $f)"
  done
}

hoogle combine --outfile=$(readlink -f ~/.hoogle.hoo) $(combines)
```

Simon Michaels suggests: 

```
#!/bin/bash
#
# Search for hoogle databases in or under the directories/files specified
# as arguments or hard-coded below (see allHoogleDbs), and combine them as
# ~/.hoogle/default.hoo.  Lets you search all your code (and installed
# haskell libs) at once.
#
# Usage:
# $ hoogle-update-db
# $ alias hoogle="hoogle --i=$HOME/.hoogle"
# $ hoogle something

# nb current hoogle cli quirks: path options should have two hyphens, one
# equals, and no tildes, eg: --d=NOTILDEFILEPATH

#set -x

ARGS=$*

function allHoogleDbs {
 for p in $ARGS ~/src/ ~/.cabal/share/ # add paths here
 do
     echo -n " $(findHoogleDbs $p)"
 done
}

function findHoogleDbs {
 find $1 -name '*.hoo'
}

function combineOpts {
for f in $*
do
 echo -n " $(readlink -f $f)"
done
}

dbs=$(allHoogleDbs)
echo Found $dbs
mkdir -p ~/.hoogle
hoogle combine --outfile=$(readlink -f ~/.hoogle/default.hoo) $(combineOpts $dbs)
echo Created ~/.hoogle/default.hoo
```

### GHCi Integration

Ever feel like having access to hoogle whilst messing around in GHCi? It's relatively easy to integrate the two. 

The following will install hoogle as a shell command, and configure GHCi to have a command ":hoogle":

* <tt>cabal install hoogle</tt>
* <tt>echo >> ~/.ghci ':def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""'</tt>

NB. the above wraps the argument in quotes before passing to the shell command, so there is no need to supply quotes; eg.

    :hoogle map
    :hoogle (a -> b) -> [a] -> [b]

Done!

On Windows you should add the same line
 :def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""
to file (XP/2003):
 C:\Documents and Settings\[your windows account]\Application Data\ghc\ghci.conf 
or(Windows Vista/7):
 C:\users\[your windows account]\Application Data\ghc\ghci.conf 

#### How it works

Next, we need to integrate it into GHCi. We can execute shell commands with GHCi via <code>:def</code>. Load up GHCi, and type the following:

 :def hoogle \x -> return $ ":!hoogle " ++ x

If this executes cleanly, you should be able to run hoogle commands from GHCi via <code>:hoogle</code>, i.e. <code>:hoogle map</code> or <code>:hoogle "(a -> b) -> [a] -> [b]"</code>. Be careful: you need the extra quotes when hoogling types, at least on my system. <code>:ho</code> works as an abbreviation of <code>:hoogle</code> (just <code>:h</code> clashes with <code>:help</code>).

Finally, we want to make this persist across GHCi sessions. GHCi loads a file called ~/.ghci before running, so simply stick the above <code>:def</code> in that file and all should work.

Contributed by [[User:DavidHouse|DavidHouse]]

### Emacs Integration
[[Haskell_mode_for_Emacs|haskell-mode]] from versions 2.4 onwards have the function haskell-hoogle, which will hoogle the identifier at point. Setup:

```
(require 'haskell-mode)
(define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
;(setq haskell-hoogle-command "hoogle")
```

You will need a web browser configured for best results. Here's an example setup for Safari:

```
(setq browse-url-browser-function 'browse-url-safari)
 (defun browse-url-safari (url &optional new-window)
  "Open URL in a new Safari window."
  (interactive (browse-url-interactive-arg "URL: "))
  (unless
      (string= ""
               (shell-command-to-string
                (concat "open -a Safari " url)))
    (message "Starting Safari...")
    (start-process (concat "open -a Safari " url) nil "open -a Safari " url)
    (message "Starting Safari... done")))
```

Alternately, you can build the command-line hoogle (darcs repo below) and uncomment the third line above, then results will appear in a buffer.
