
module Haddock(haddock) where

import Util
import Text.HTML.TagSoup


haddock :: String -> IO ()
haddock "keyword" = do
    src <- readFile "temp/keyword/keyword.html"
    let items = concatMap keywordFormat $ partitions (~== "<a name>") $
                takeWhile (~/= "<div class=printfooter>") $ parseTags src
    writeFile "temp/keyword/hoogle.txt" (unlines $ keywordPrefix ++ items)


haddock x = do
    let res = "temp/" ++ x ++ "/hoogle.txt"
    b <- doesFileExist res
    when (not b) $ do
        when (x == "base") $ basePatchup

        b <- doesFileExist $ "temp/" ++ x ++ "/setup.exe"
        when (not b) $ setupFile ("temp/" ++ x ++ "/setup.exe")

        dir <- getCurrentDirectory
        bracket_ (setCurrentDirectory $ "temp/" ++ x) (setCurrentDirectory dir) $ do
            system_ "setup configure"
            system_ "setup haddock --hoogle"

        copyFile ("temp/" ++ x ++ "/dist/doc/html/" ++ x ++ "/" ++ x ++ ".txt") res


basePatchup = do
    -- FIX THE CABAL FILE
    let cabal = "temp/base/base.cabal"
    x <- readFile' cabal
    let f x = not $ "ghc.prim" `isSubstrOf` map toLower x
    x <- return $ unlines $ filter f $ lines x
    writeBinaryFile cabal x

    -- INCLUDE FILE
    copyFile "Config.h" "temp/base/include/HsBaseConfig.h"


setupFile file = do
    b <- doesFileExist "temp/setup.exe"
    when (not b) $ do
        writeFile "temp/Setup.hs" "import Distribution.Simple; main = defaultMain"
        system_ "ghc --make temp/Setup.hs -o temp/setup.exe"
    copyFile "temp/setup.exe" file



keywordPrefix =
    ["-- Hoogle documentation, generated by Hoogle"
    ,"-- From http://www.haskell.org/haskellwiki/Keywords"
    ,"-- See Hoogle, http://www.haskell.org/hoogle/"
    ,""
    ,"-- | Haskell keywords, always available"
    ,"@package keyword"
    ]


keywordFormat x = concat ["" : docs ++ ["@keyword " ++ n] | n <- name]
    where
        name = words $ f $ fromAttrib "name" (head x)
        docs = zipWith (++) ("-- | " : repeat "--   ") $
               concat $ intersperse [""] $
               map (docFormat . takeWhile (~/= "<div class=editsection>")) $
               partitions isBlock x

        isBlock (TagOpen x _) = x `elem` ["p","pre"]
        isBlock _ = False

        f ('.':'2':'C':'_':xs) = ' ' : f xs
        f ('.':a:b:xs) = chr res : f xs
            where [(res,"")] = readHex [a,b]
        f (x:xs) = x : f xs
        f [] = []


docFormat :: [Tag] -> [String]
docFormat (TagOpen "pre" _:xs) = map ("> " ++) $ lines $ innerText xs
docFormat (TagOpen "p" _:xs) = g 0 [] $ words $ f xs
    where
        g n acc [] = [unwords $ reverse $ acc | acc /= []]
        g n acc (x:xs) | nx+1+n > 70 = g n acc [] ++ g nx [x] xs
                       | otherwise = g (n+nx+1) (x:acc) xs
            where nx = length x

        f (TagOpen "code" _:xs) = "<tt>" ++ innerText a ++ "</tt>" ++ f (drop 1 b)
            where (a,b) = break (~== "</code>") xs
        f (x:xs) = h x ++ f xs
        f [] = []

        h (TagText x) = unwords (lines x)
        h (TagOpen "a" xs) = ""
        h (TagClose "a") = ""
        h (TagClose "p") = ""
        h x = error $ "docFormat.f: " ++ show x
